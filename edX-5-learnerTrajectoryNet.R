## ====================================================================================== ##
# Title:        Creating Course Trajectory Networks Using Student Event Logs
#               Single Period Networks
# Project:      edX user trajectory analysis
#
#     Copyright 2017-2018 Michael Ginda
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#     
#     http://www.apache.org/licenses/LICENSE-2.0
#     
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
# Authors:      Michael Ginda
# Affiliation:  Indiana University
# 
# Description:  This script takes processed students' edX event log (CSV) to 
#               create a learner transition networks using the igraph library. 
#               The network represents student's transition between EdX blocks 
#               learning modules using a student's event log of click actions in 
#               an EdX course. The script relies on two data sources:
#                  * course module sequencing and hierarchy structure extracted 
#                    from a course state database;
#                  * individual student's event logs formatted using the 
#                    script, edX-studentLogFormatter.R.
#
#               Networks represent events at the lowest level an EdX course's 
#               module hierarchy structure (level 4). Network objects are exported
#               as JSON graphs, and as a node and edge list CSV files, in the 
#               project directory, "./networks/".
# 
# File input stack: 
#            1) A processed edX Course structure and content module list:
#               - {org}+{course}+{term}-module-lookup.csv;
#               - extracted by script, edX-0-courseStructureMeta.R;
#            2) A list of student userIDs from an edX course that are active
#	           		and have usable data:
#               - {org}-{course}-{term}-auth_user-students-active.csv;
#               - extracted by script, edX-3-studentLogFormatter.R;
#            3) A "studentevents_processed" directory with one or more
#               CSV of processed student event log file(s):
#               - {userID}.csv;
#               - generated by script, edX-3-studentLogFormatter.R, 
#                   
# Output files:                        
#            1) A project directory "./networks/" containing one or 
#               more JSON learner trajectory networks:
#               - {org}-{course}-{term}-{userID}.json;
#            2) A project directory "./networks/nodes/" containing one or 
#               more CSV student node lists:
#               - {userID}-nodes.csv;
#            3) A project directory "./networks/edges/" containing one or 
#               more sets of CSV student edge lists:
#               - {userID}-edges.csv;
#            4) A list capturing student userIDs that are associated with
#               a learner trajectory network after processing:
#               - {org}-{course}-{term}-auth_user-students-hasNet.csv;
#            5) A list capturing student userIDs that are associated with only
#               one event after processing:
#               - {org}-{course}-{term}-auth_user-students-auth_user-oneEvent.csv;
#            6) A list capturing student userIDs that have no network if self-loops
#               are removed during processing to create a learner trajectory network;
#				        (not always produced):
#               - {org}-{course}-{term}-auth_user-students-auth_user-selfLoops.csv;
#
# Package dependencies: stringr, plyr, igraph, tcltk, jsonlite, 
#                       and a fork of graph-importer-R functions
#
# Change log:
#   2017.11.02. Version 1: Initial Code - environment, look up table
#   2017.11.03. Fix look-up table; create edge and node list - initial network created
#   2017.11.06. Update JSON export function; update network statistics; load package 
#               reqs; export files as CSV and JSON
#   2017.11.09. Updated node list creation to add indicators of course hierarchy: third 
#               level module sequence groups and first level course chapters/week groups; 
#               adjusted the maximum time for event from 150 minutes to 60; remove edge 
#               type from export, as type of transition is not captured by this field; 
#               convert node and edge factor and time variables to characters and numeric 
#               variable types to remove warnings given by igraph creation function.
#   2017.11.14  Clean up script introduction text.
#   2017.11.22  Update lookup loops to skip over sequential modules that are not in 
#               currently in course structure. Update edge list loop to identify and  
#               remove low level modules that are not in course structure.
#   2017.12.15  Creates courseStrNodes function, that updates script that took a course 
#               structure and converted it into a node list; the function now allows for 
#               user to specify if they want to include the non-content modules in the 
#               structure or not.
#   2018.01.18  Version 2: Major revision of script to align with revisions made to the 
#               "edX-2-studentLogFormatter.R" script, e.g. moved module identifier 
#               look-up routine, calculation of duration of time at event, and removal 
#               of modules from event log that are not in final course structure. 
#               Updated function courseStrNodes to include mod_hex_id field instead 
#               of full module.key identifier, added courseID field to generic node list.
#               Updated individual's edge and node list creation to handle new fields 
#               created using the log formatter script.
#               Added directory structure elements to create node and edge directories for 
#               to save results, and edge cases (one event and logs with only self loops).
#               Added control features to sort out edge case of one event and only have 
#               an edge list with self-loop events.
#   2018.05.21  Script format alignment. Update file loads course structure and user list.
#   2018.05.22  Updated network creation loop: file exports, and added self-loops field, 
#               to networks; updated script add networks directory if none found.
#   2018.07.02  File out/input stack updates.
#   2018.09.07  Forked script for revised data format. Updated Problem module calculation
#               for accurate results and speeding up processing.
#
## ====================================================================================== ##
#### Environment setup ####
## Clean the  ####
rm(list=ls()) 
options(scipen=90)

## Load required packages
require("stringr")    #Stringr 
require("plyr")       #joins
require("igraph")     #network formatting
require("tcltk2")     #for OS independant GUI file and folder selection
require("jsonlite")   #Exporting networkfiles as JSON formatted objects for visualization

#### Functions ####
#exportGraph v2.0 Updated for this project
# Allow to both export and convert an igraph object to JSON.
# @param g the igraph object
# @param filename the out filename where to store the converted json. This parameter is optional. 
#        The funcion returns a json anyway. If this parameter is set it will also be saved into the file
# @return json string
exportGraph <- function(g,filename){
  #convert graph into a list
  graph <- list()
  graph$directed <- is.directed(g)
  graph$name <- g$name
  graph$vertices <- as_data_frame(g, what="vertices")
  graph$edges <- as_data_frame(g, what = "edges")
  #Time as posixct
  graph$edges$time <- as.POSIXct(graph$edges$time,origin="1970-01-01",tz="EST") 
  
  #polish vertices
  row.names(graph$vertices) <- NULL
  if(ncol(graph$vertices)==0) graph$vertices <- NULL #in case the 
  
  #convert list into a json
  json.content <- toJSON(graph, pretty=TRUE)
  #write json into a file
  if(!missing(filename)) {
    sink(filename)
    cat(json.content)
    sink()
  }
  #return the json in case you need it
  return(json.content)
}

#courseStrNodes v1.0 
# Converts course structure data set into a node list with only fourth level course learning modules.
# @param nc The nc parameter is set by a user to indicate the course node list output needed for their processed
#           data; nc=TRUE indicates that course's information, wiki, and student progress pages were maintained in
#           the data processing steps, nc=FALSE indicates that the course's information, wiki, and progress pages were
#           removed from the logs for analysis purposes.
# @return
courseStrNodes <- function(courseStr,nc=FALSE){
  if(missing(courseStr)){stop("No Course Structure provided")
    }
  else {
    if(nc==FALSE){
      ## Network Node List Creation
      ## Generic Node list and embedded course hierarchy (levels 3-1)
      #Create generical node list for all students in a course
      nodes <- courseStr[courseStr$treelevel==4,c(2,3,4,5,7,12)]
      
      #Rename fields for node list and row numbers
      #L3 is the course module identifier for the fourth level module nodes
      names(nodes) <- c("mod_hex_id","courseID","module.type","desc","order","L3")
      rownames(nodes) <- 1:nrow(nodes)
      #Fields for parent and grand parent look-ups from course structure
      nodes[,"L2"]<-NA
      nodes[,"L2label"]<-NA
      nodes[,"L1"]<-NA
      nodes[,"L1label"]<-NA

      #Loop for looking up parent identifiers and labels from the course structure
      for(i in 1:nrow(nodes)){
        nodes[i,]$L2 <- as.character(courseStr[courseStr$mod_hex_id==as.character(nodes[i,]$L3),]$parent)
        nodes[i,]$L2label <- as.character(courseStr[courseStr$mod_hex_id==nodes[i,]$L2,]$name)
        nodes[i,]$L1 <- as.character(courseStr[courseStr$mod_hex_id==as.character(nodes[i,]$L2),]$parent)
        nodes[i,]$L1label <- as.character(courseStr[courseStr$mod_hex_id==nodes[i,]$L1,]$name)
      }
      #Reorders columns to move order to apply a conversion to node types of factors
      nodes <- nodes[,c(2,1,3,4,7:10,5)]
      for(i in 1:4){
        nodes[,i] <- as.character(nodes[,i])
      }
      nodes
      
    } else if(nc==TRUE){
      #Modifies module order by three, to add additional modules for non-learning object event pages (wikis, progressm and course info)
      courseStr[2:nrow(courseStr),]$order <- courseStr[2:nrow(courseStr),]$order + 3
      #Replication of fields
      mod_hex_id <- c("info","progress","wiki")
      courseID <- rep(courseStr$courseID[1],3)
      id <- c(paste0(courseStr$courseID[1],"type@",mod_hex_id[1]),
              paste0(courseStr$courseID[1],"type@",mod_hex_id[2]),
              paste0(courseStr$courseID[1],"type@",mod_hex_id[3]))
      mod_type <- rep(c("course_info"),3)
      name <- c("Course Information","Student Progress","Course Wikis")
      markdown <- NA
      #Top level order is set to pre-pend the learning object data
      order <- seq(2,4,1)
      #All actions are aggregated to a general type of event, all leaf nodes are set to parent
      childOrder <- rep(1,3)
      #Assign events to lowest level of tree for visualization
      treelevel <- rep(4,3)
      #Parent identifiers
      chpModPar	<- seqModPar <- NA
      vrtModPar <- "course"
      #Parent ID set to course
      parent <- rep("course",3)
      modparent_childlevel <- paste(parent,childOrder,sep="/")
      d <- data.frame(id,mod_hex_id,courseID,mod_type,name,markdown,order,childOrder,treelevel,
                      chpModPar,seqModPar,vrtModPar,parent,modparent_childlevel)
      #Add three new rows to course structure
      courseStr <- rbind(courseStr,d)
      rm(d,id,mod_hex_id,courseID,mod_type,name,markdown,order,childOrder,treelevel,
         chpModPar,seqModPar,vrtModPar,parent,modparent_childlevel)
      #Resets course module order
      courseStr <- courseStr[order(courseStr$order),]
      rownames(courseStr) <- 1:nrow(courseStr)
    
      ## Network Node List Creation
      ## Generic Node list and embedded course hierarchy (levels 3-1)
      #Create generical node list for all students in a course
      nodes <- courseStr[courseStr$treelevel==4,c(2,3,4,5,7,12)]
      #Rename fields for node list and row numbers
      #L3 is the course module identifier for the fourth level module nodes
      names(nodes) <- c("mod_hex_id","courseID","module.type","desc","order","L3")
      rownames(nodes) <- 1:nrow(nodes)
      #Fields for parent and grand parent look-ups from course structure
      nodes[,"L2"]<-NA
      nodes[,"L2label"]<-NA
      nodes[,"L1"]<-NA
      nodes[,"L1label"]<-NA
      
      #Loop for looking up parent identifiers and labels from the course structure
      for(i in 1:nrow(nodes)){
        nodes[i,]$L2 <- as.character(courseStr[courseStr$mod_hex_id==as.character(nodes[i,]$L3),]$parent)
        nodes[i,]$L2label <- as.character(courseStr[courseStr$mod_hex_id==nodes[i,]$L2,]$name)
        nodes[i,]$L1 <- as.character(courseStr[courseStr$mod_hex_id==as.character(nodes[i,]$L2),]$parent)
        nodes[i,]$L1label <- as.character(courseStr[courseStr$mod_hex_id==nodes[i,]$L1,]$name)
      }
      #Reorders columns to move order to apply a conversion to node types of factors
      nodes <- nodes[,c(2,1,3,4,7:10,5)]
      for(i in 1:4){
        nodes[,i] <- as.character(nodes[,i])
      }
      str(nodes)
      #Updates to the course information levels (not worth changing above, causes error in for loop)
      nodes[1:3,c(6,8)] <- "Course Information"  
      nodes
    } else stop("invalid 'nc' specification, cannot determine whether to maintain non-content modules in analysis")
  }
}

#### Paths ####
## Sets path to processed data
path_output = tclvalue(tkchooseDirectory())

##Creates a network directory if none exists in the project space
if(!file_test("-d", file.path(paste0(path_output,"/networks/")))){
  if(file_test("-f", file.path(paste0(path_output,"/networks/")))){
    stop("Path can't be created because a file with that name already exists.")
  } else {
    dir.create(file.path(path_output,"networks"))
  }
}

#Vector of new directories for network analysis: node and edges of students, 
#and logs for students with one event
subDir = c("nodes","edges","oneEvent","selfLoops")
for(i in 1:length(subDir)){
  if(!file_test("-d", file.path(paste0(path_output,"/networks/",subDir[i])))){
    if(file_test("-f", file.path(paste0(path_output,"/networks/",subDir[i])))){
      stop("Path can't be created because a filef with that name already exists.")
    } else {
      dir.create(file.path(paste0(path_output,"/networks/",subDir[i])))
    }
  }
}


#### Main Processings ####
## Start timer to track how long the script takes to execute
start <-  proc.time() #save the time (to compute elapsed time of script)

## Loads in course structure course structure
struct <- read.csv(list.files(full.names = TRUE, recursive = FALSE, 
                                 path = paste0(path_output,"/course/"),
                                 pattern = "module-lookup.csv"),header=T)
courseID <- gsub("\\+","\\-",struct$courseID)[1]

## Modification of course structure for accurate node representation for courses
nodes <- courseStrNodes(courseStr=struct, nc=F)

## Load list of users to create list of log file paths
logFilePaths <- read.csv(list.files(full.names = TRUE, recursive = FALSE, 
                                    path = paste0(path_output,"/userlists/"),
                                    pattern = "-auth_user-students-active.csv$"),header=T)
names(logFilePaths) <- "id"
logFilePaths <- paste0(path_output,"/studentevents_processed/",logFilePaths$id,".csv")
rm(struct)

#### Process student event log to create network graph files ####
numLogs <- length(logFilePaths) 

#For loop processes each student event log to create a transition network
selfLoopKeep <- TRUE

## Loop to create networks
for(i in 1:numLogs){
    message("Processing log file ", i, " of ", numLogs)
    print(proc.time() - start)
    ## Load data set
    data <- read.csv(logFilePaths[i])
    ## Set filename IDs
    sid <- data$user_id[1]
    if(nrow(data)>1){
      #Updates Time field to R compliant format
      data$time <- as.POSIXct(data$time, tz="EST",format='%Y-%m-%d %H:%M:%S')
      
      ## Edge List Created
      #Takes user_id, mod_hex_id, order, time, sessions, and t-session fields
      edges <- data[,c(1:3,7,9:10)]
      #Renames order field to sequence position
      names(edges)[3] <- c("seqpos")
      
      #Creates transitions in targets in edge file
      edges <- cbind(edges[1:(nrow(edges)-1),c(1:3,5,6)],edges[2:nrow(edges),c(2:6)])
      #Renames fields
      names(edges) <- c("user_id","from","s.seqpos","s.session","s.tsession","to","t.seqpos","time","t.session","t.tsession")
      #Assigns edge direction and tree distance based on module sequence order
      edges$dir <- ifelse(edges$s.seqpos < edges$t.seqpos,c("p"),c("n"))
      edges$dis <- edges$t.seqpos - edges$s.seqpos
      #Adds self loops flag, and reorganizes the columns
      edges$sl <- 0
      if(selfLoopKeep==T){
        if(length(edges[edges$to==edges$from,]$sl)>=1){
        edges[edges$to==edges$from,]$sl <- 1
        }
        edges <- edges[,c(2,6,3:5,7,9,10,8,11:13,1)]
      } else {
        edges <- edges[!(edges$to==edges$from),c(2,6,3:5,7,9,10,8,11:13,1)]
      }
      str(edges)
      if(nrow(edges)>0){
        ## Node Statistics
        ## Module Session, Date, Event Frequencies, and total time associated with the module event
        nodes_t <- ddply(data, ~ mod_hex_id,summarize,
                      unq_stu=length(unique(user_id)),
                      sessions=length(unique(tsess)),
                      days=length(unique(as.Date(time))),
                      events=length(tsess),
                      totalTime=sum(period))

        ## Module Edge count events directionality and distance
        #Node source out-degree variable trajectory (out forward progress or backward progress)
        if(nrow(edges[edges$dir=='p',])>0){
          ef <- ddply(edges[edges$dir=='p',], ~ from, summarize, 
                      forward_o = length(user_id))
        } else {
          ef <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=2))
          names(ef) <- c("from","forward_o")
          ef$from <- nodes_t$mod_hex_id
        }
        if(nrow(edges[edges$dir=='n',])>0){
          eb <- ddply(edges[edges$dir=='n',], ~ from, summarize, 
                      backward_o = length(user_id))
        } else {
          eb <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=2))
          names(eb) <- c("from","backward_o")
          eb$from <- nodes_t$mod_hex_id
        }
        es <- join(ef,eb,by="from",type='full')
        rm(ef,eb)  
        ## Node target in-degree variable counting tranistions made by forward progress or by repeated visit
        if(nrow(edges[edges$dir=='p',])>0){
          ep <- ddply(edges[edges$dir=='p',], ~ to, summarize, 
                      progress_i = length(user_id))
        } else {
          ep <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=2))
          names(ep) <- c("to","progress_i")
          ep$to <- nodes_t$mod_hex_id
        }
        if(nrow(edges[edges$dir=='n',])>0){
          er <- ddply(edges[edges$dir=='n',], ~ to, summarize, 
                      recurse_i = length(user_id))
        } else {
          er <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=2))
          names(er) <- c("to","recurse_i")
          er$to <- nodes_t$mod_hex_id
        }
        et <- join(ep,er,by="to",type='full')  
        rm(ep,er)
        ## Node self-loop count
        if(nrow(edges[edges$sl==1,])>0){
          sl <- ddply(edges[edges$sl==1,], ~ from, summarize, 
                      sl = length(user_id))
        } else {
          sl <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=2))
          names(sl) <- c("from","sl")
          sl$from <- nodes_t$mod_hex_id
        }
        #Rename fields for joining to nodes_t
        names(sl)[1] <- names(et)[1] <- names(es)[1] <- c("mod_hex_id")
        nodes_t <- join(nodes_t,et,by='mod_hex_id',type='left')
        nodes_t <- join(nodes_t,es,by='mod_hex_id',type='left')
        nodes_t <- join(nodes_t,sl,by='mod_hex_id',type='left')  
        rm(es,et,sl)  

        ## Problem module event calculations
        ## Problem module event calculations
        ag <- ddply(data[data$event_type==c("problem_check") & data$event_source==c("server"),],~mod_hex_id,summarise,
                    attempts = max(attempts),
                    points = max(grade))
        if(nrow(ag)>0){
          nodes_t <- join(nodes_t,ag,by='mod_hex_id',type='left')
          rm(ag)  
        } else {
          nodes_t$attempts <- NA
          nodes_t$points <- NA
          rm(ag)
        }
        
        ## Video Module time calculations (video)
        #Video load events and time calc
        if(length(data[data$event_type==c("load_video"),]$event_type)>0){
          vd <- ddply(data[data$event_type==c("load_video"),],~mod_hex_id,summarize,
                      loads = length(session),
                      load_time = sum(period))
        } else {
          vd <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=3))
          names(vd) <- c("mod_hex_id","loads","load_time")
          vd$mod_hex_id <- nodes_t$mod_hex_id
        }  
        #Video play events and time calc
        if(length(data[data$event_type==c("play_video"),]$event_type)>0){
          pl <- ddply(data[data$event_type==c("play_video"),],~mod_hex_id,summarize,
                      plays = length(session),
                      play_time = sum(period))
        } else {
          pl <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=3))
          names(pl) <- c("mod_hex_id","plays","play_time")
          pl$mod_hex_id <- nodes_t$mod_hex_id
        }       
        #Video pause events and time calc
        if(length(data[data$event_type==c("pause_video"),]$event_type)>0){
          pa <- ddply(data[data$event_type==c("pause_video"),],~mod_hex_id,summarize,
                      pauses = length(session),
                      pause_time = sum(period))
        } else {
          pa <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=3))
          names(pa) <- c("mod_hex_id","pauses","pause_time")
          pa$mod_hex_id <- nodes_t$mod_hex_id
        }
        #Video Seeking events and time calcs
        if(length(data[data$event_type==c("seek_video"),]$event_type)>0){
          sk <- ddply(data[data$event_type==c("seek_video"),],~mod_hex_id,summarize,
                      seeks = length(session),
                      seek_time = sum(period))
           } else {
          sk <- as.data.frame(matrix(nrow=nrow(nodes_t),ncol=3))
          names(sk) <- c("mod_hex_id","seeks","seek_time")
          sk$mod_hex_id <- nodes_t$mod_hex_id
        }
        
        vd <- join(vd,pl,by="mod_hex_id",type="full")
        vd <- join(vd,pa,by="mod_hex_id",type="full")
        vd <- join(vd,sk,by="mod_hex_id",type="full")
        nodes_t <- join(nodes_t,vd,by="mod_hex_id",type="left")
        rm(pl,pa,sk,vd)
      
        #Merges course node list with student's temp node list
        nodes_t <- join(nodes,nodes_t,by='mod_hex_id',type='left')
        nodes_t <- nodes_t[,c(2,1,3:ncol(nodes_t))]
        
        #Clean-up for variables used for all modules (non-used modules get 0 values)
        nodes_t[is.na(nodes_t$unq_stu),]$unq_stu <- 0
        nodes_t[is.na(nodes_t$sessions),]$sessions <- 0 
        nodes_t[is.na(nodes_t$days),]$days <- 0
        nodes_t[is.na(nodes_t$events),]$events <- 0
        nodes_t[is.na(nodes_t$totalTime),]$totalTime <- 0
        nodes_t[is.na(nodes_t$progress_i),]$progress_i <- 0
        nodes_t[is.na(nodes_t$recurse_i),]$recurse_i  <- 0
        nodes_t[is.na(nodes_t$forward_o),]$forward_o <- 0
        nodes_t[is.na(nodes_t$backward_o),]$backward_o  <- 0
        nodes_t[is.na(nodes_t$sl),]$sl  <- 0
        #problem question variables
        nodes_t[nodes_t$module.type==c("problem+block") & is.na(nodes_t$attempts) , 19:20] <- 0
        
        #Video watching variables
        if(nrow(nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$loads),])>0){
          nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$loads),21:22] <- 0  
        }
        if(nrow(nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$plays),])>0){
          nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$plays),23:24] <- 0
        }
        if(nrow(nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$pauses),])>0){
          nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$pauses),25:26] <- 0 
        }
        if(nrow(nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$seeks),])>0){
          nodes_t[nodes_t$module.type==c("video+block") & is.na(nodes_t$seeks),27:28] <- 0 
        }
    
        ## Writing node and edge lists
        write.csv(nodes_t,paste0(path_output,"/networks/",subDir[1],"/",sid,"-nodes.csv"),row.names=F)
        str(nodes_t)
        #converts factor variables to characters for exporting graph and time variables to unicode
        write.csv(edges,paste0(path_output,"/networks/",subDir[2],"/",sid,"-edges.csv"),row.names=F)
        
        #remove time as a factored variable (reconverted back to time in export) 
        edges$time <- as.numeric(edges$time)
        
        ## Update Full Module Node List with node statistics
        g <- graph_from_data_frame(edges,directed=T,vertices=nodes_t)
        g$name <- sid
        exportGraph(g,filename=paste0(path_output,"/networks/",nodes$courseID[1],"-",sid,".json"))
      } else {
        write.csv(data,paste0(path_output,"/networks/",subDir[4],"/",sid,".csv"),row.names=F)
      }
    } else {
      write.csv(data,paste0(path_output,"/networks/",subDir[3],"/",sid,".csv"),row.names=F)
    }
}

## Saves out list of user IDs for students with usable logs and unusable logs
users <- list.files(path=paste0(path_output,"/networks/",subDir[2]),pattern=".csv")
users <- data.frame(do.call('rbind',strsplit(users,"\\-")))
names(users) <- c("userID","v")
write.csv(x=users[,1], file=paste0(path_output,"/userlists/",courseID,"-auth_user-hasNet.csv"),row.names = F)

users <- list.files(path=paste0(path_output,"/networks/",subDir[3]),pattern=".csv")
users <- data.frame(do.call('rbind',strsplit(users,"\\.")))
names(users) <- c("userID","v")
write.csv(x=users[,1], file=paste0(path_output,"/userlists/",courseID,"-auth_user-oneEvent.csv"),row.names = F)

if(selfLoopKeep==F){
  users <- list.files(path=paste0(path_output,"/networks/",subDir[4]),pattern=".csv")
  users <- data.frame(do.call('rbind',strsplit(users,"\\.")))
  names(users) <- c("userID","v")
  write.csv(x=users[,1], file=paste0(path_output,"/userlists/",courseID,"-auth_user-user_id-selfLoops.csv"),row.names = F)
}
#### Finishing details ####
#Indicate completion
message("\n**** Complete! ****\n")

## Script processing time feedback
#print the amount of time the script required
cat("\n\n\nComplete script processing time details (in min):\n")
print((proc.time()[3] - start[3])/60)

## Clear environment variables
rm(list=ls())