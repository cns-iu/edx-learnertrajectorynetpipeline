## ====================================================================================================== ##
# Title:        Aggregating Student Activity Feature Extraction from Event Logs       
# Project:      edX user trajectory analysis
#
#     Copyright 2017 Michael Ginda
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#     
#     http://www.apache.org/licenses/LICENSE-2.0
#     
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
# Authors:      Michael Ginda
# Affiliation:  Indiana University
# 
# Description:  This script processes sets of processed student edX logs to extract frequential statistics
#               of student activity in an EdX course (e.g. number of sessions, events, unique modules, event_types),
#               and basic temporal period. The script will calculate statistics courses that use video modules, 
#               ungraded problem modules, and open assessment modules, and navigation events. Other types of
#               course module types and associated types of events that may be apart of an EdX course are not 
#               included here, but may be added at a later date.
#                
# File input stack: 
#               1) Course Structure data set - generated by A.B. python script (needs converted to R)
#               2) A list of student identifiers for students with usable logs in the data set;
#               3) Course User data table to extract final student grades and self-reported demographics;
#               4) Folders containing one or more "*.csv" processed student event logs
#                                            - generated by script by "edX-2a-studentLogFormatter.R"
#
# Package dependencies: zoo, magrittr, tcltk, reshape, ddply, graph-importer-R 
#
# Changelog:
#   2018.01.23. Initial Code - Environment Set up and initial aggregation loop
#   2018.01.24.
#   2018.01.25. Completed initial implementation of code, bug test loop with log 
#               data and verifiedaggregating  student activity variables for 
#               analysis and visualization. Exported data sets to csv files.
#	2018.02.05  Clean-up for sharing on GitHub and alignment across workflow.
#
## ====================================================================================================== ##
######### Setup ########## 
## _Clean the environment ####
rm(list=ls()) 
options(scipen=90)

## _start timer to track how long the script takes to execute
start <-  proc.time() #save the time (to compute elapsed time of script)

## _Load required packages #####
require("magrittr")   #Pipe tool
require("zoo")        #dataPrep
require("stringr")    #Stringr 
require("data.table") #Data Table
require("plyr")       #DPLYR
require("tcltk2")     #for OS independent GUI file and folder selection

####Functions
#getData
##The getData is a function used to select a CSV file listing student identifiers/course structure 
#to be CSV is placed in the variable 'data' in the global environment
getData <- function() {
  name <- tclvalue(tkgetOpenFile(
    filetypes = "{ {CSV Files} {.csv} } { {All Files} * }"))
  if (name == "")
    return(data.frame()) # Return an empty data frame if no file was selected
  data <- read.csv(name)
  assign("data", data, envir = .GlobalEnv)
  cat("The imported data are in csv_data\n")
}

######### Main ########## 
#Creates paths used to locate directory course data used in analyis
path_data = tclvalue(tkchooseDirectory())

#Output Path
path_output = tclvalue(tkchooseDirectory())

#Creates subDir where data outputs are saved
subDir = c("studentActivity")
for(i in 1:length(subDir)){
  if(!file_test("-d", file.path(path_output, subDir[i]))){
    if(file_test("-f", file.path(path_output, subDir[i]))){
      stop("Path can't be created because a file with that name already exists.")
    } else {
      dir.create(file.path(path_output, subDir[i]))
    }
  }
}

#Course Identifiers
getData()
courseID <- strsplit(as.character(data$courseID[1]),split="\\:")[[1]][2]
courseID <- substr(courseID,1,nchar(courseID)-1)
rm(data)

#Read in list of relevant students
getData()
students <- data
names(students) <- "id"

#Read in students table from course learner activity database
#Data must be extracted from student user database {org}-{course}-{run}-auth_user-{site}-analytics.json 
getData()
#Subset to keep user id, grade, certificate status, gender, year of birth (yob), and level of education (loe)
stdData <- data[,c(1,10,12:15)]
rm(data)

#Creates a subset of the stdData to only relevant students
students <- join(students,stdData,type="left")
names(students)[1] <- "user_id"

#Creates list paths to load individual student event logs
logFiles <- paste0(path_data,"/",students$user_id,".csv")
numLogs <- length(logFiles) 

#Creates dataframe shells for saving user analysis results
#for types of events and modules used in a course
stdData <- NULL
vidData <- NULL
prbData <- NULL
oaData <- NULL
navData <- NULL

#Loop for calculating all user statistics and appending results to appropriate dataframe
for(i in 1:numLogs){
  message("Processing log file ", i, " of ", numLogs)
  print(proc.time() - start)
  ###Load data set
  temp <- read.csv(logFiles[i])
  temp$time <- as.POSIXct(temp$time, tz="EST",format='%Y-%m-%d %H:%M:%S')
  
  #Navigation Distance between events
  temp$dis <- NA
  temp[1:nrow(temp)-1,]$dis <- temp[2:nrow(temp),]$order - temp[1:nrow(temp)-1,]$order
  temp[nrow(temp),]$dis <- 0
  
  #count statistics for general activity
  std <- ddply(temp, .(user_id), summarise,
               sessions = length(unique(tsess)),
               days_unq = length(unique(trunc(time,"days"))),
               total_time = sum(period),
               mods_unq =  length(unique(mod_hex_id)),
               events = length(user_id)
              ) 
  stdData <- rbind(stdData,std)
  
  #Video Event statistics
  vid <- NULL
  if(nrow(temp[temp$module_type==c("video+block"),])>1){
    vid <- ddply(temp[temp$module_type==c("video+block"),], .(user_id), summarise,
                 vid_mods = length(unique(mod_hex_id)),
                 vid_meanDate = mean(as.numeric(time),na.rm=T),
                 vid_events = length(user_id)
                 )  
    #Play Video Stats
    if(nrow(temp[temp$module_type==c("video+block") & temp$event_type==c("play_video"),])>1){
      vid <- cbind(vid,ddply(temp[temp$module_type==c("video+block") & temp$event_type==c("play_video"),],
                             .(user_id), summarise,
                             vid_playEvents = length(user_id),
                             vid_playTime = sum(period))[2:3])
    } else {
      vid_playEvents <- 0
      vid_playTime <- 0
      vid <-cbind(vid,cbind(vid_playEvents,vid_playTime))      
      rm(vid_playEvents,vid_playTime)
    }
    #Pause Video Stats
    if(nrow(temp[temp$module_type==c("video+block") & temp$event_type==c("pause_video"),])>1){
      vid <- cbind(vid,ddply(temp[temp$module_type==c("video+block") & temp$event_type==c("pause_video"),],
                             .(user_id), summarise,
                             vid_pauseEvents = length(user_id),
                             vid_pauseTime = sum(period))[2:3])
    } else {
      vid_pauseEvents <- 0
      vid_pauseTime <- 0
      vid <-cbind(vid,cbind(vid_pauseEvents,vid_pauseTime))      
      rm(vid_pauseEvents,vid_pauseTime)
    }
    #Seek Video Stats
    if(nrow(temp[temp$module_type==c("video+block") & temp$event_type==c("seek_video"),])>1){
      vid <- cbind(vid,ddply(temp[temp$module_type==c("video+block") & temp$event_type==c("seek_video"),],
                             .(user_id), summarise,
                             vid_seekEvents = length(user_id),
                             vid_seekTime = sum(period))[2:3])
    } else {
      vid_seekEvents <- 0
      vid_seekTime <- 0
      vid <-cbind(vid,cbind(vid_seekEvents,vid_seekTime))      
      rm(vid_seekEvents,vid_seekTime)
    }
    #Stop Video Stats
    if(nrow(temp[temp$module_type==c("video+block") & temp$event_type==c("stop_video"),])>1){
      vid <- cbind(vid,ddply(temp[temp$module_type==c("video+block") & temp$event_type==c("stop_video"),],
                             .(user_id), summarise,
                             vid_stopEvents = length(user_id),
                             vid_stopTime = sum(period))[2:3])
    } else {
      vid_stopEvents <- 0
      vid_stopTime <- 0
      vid <-cbind(vid,cbind(vid_stopEvents,vid_stopTime))      
      rm(vid_stopEvents,vid_stopTime)
    }
    #Video Navigation Event Count (seq and mod_access events)
    vid$vid_navEvents <- vid$vid_events - sum(vid[,c(5,7,9,11)])
    #Video interaction time (play, pause, seek; stop excluded)
    vid$vid_time <- sum(vid[,c(6,8,10)])
    vid <- vid[,c(1:5,7,9,11,13,14,6,8,10,12)]
    } else {
    vid$user_id <- temp$user_id[1]
    vid <- as.data.frame(cbind(t(vid), matrix(data=rep(0,13),nrow=1,ncol=13)))
    names(vid) <- c("user_id","vid_mods","vid_meanDate","vid_events","vid_playEvents","vid_pauseEvents","vid_seekEvents", 
                    "vid_stopEvents","vid_navEvents","vid_time","vid_playTime","vid_pauseTime","vid_seekTime","vid_stopTime")
    }
  #Combined student video stats to table of all students video stats
  vidData <- rbind(vidData,vid)

  #Problems Event
  prb <- NULL
  if(nrow(temp[temp$module_type==c("problem+block"),])>1){
    prb <- ddply(temp[temp$module_type==c("problem+block"),], .(user_id), summarise,
                 prb_meanDate = mean(as.numeric(time),na.rm=T),
                 prb_events = length(user_id)
                 ) 
    #Problem Check
    if(nrow(temp[temp$module_type==c("problem+block") & temp$event_type==c("problem_check"),])>1){
      prb <- cbind(prb,ddply(temp[temp$module_type==c("problem+block") & temp$event_type==c("problem_check"),],
                             .(user_id), summarise,
                             prb_mod = length(unique(mod_hex_id)),
                             prb_attempts = length(user_id),
                             prb_meanAttempts = length(user_id)/length(unique(mod_hex_id)),
                             prb_checkTime = sum(period),
                             prb_correct = length(event.success[temp$event.success==c("correct") & !is.na(temp$event.success)]),
                             prb_totalPoints = sum(event.grade))[,2:7]) 
    } else {
      prb <- cbind(prb,matrix(0,nrow=1,ncol=6))
      names(prb)[4:9] <- c("prb_mod","prb_correct","prb_attempts","prb_meanAttempts","prb_checkTime","prb_totalPoints")
    }
    #Problem Show
    if(nrow(temp[temp$module_type==c("problem+block") & temp$event_type==c("problem_show"),])>1){
      prb <- cbind(prb,ddply(temp[temp$module_type==c("problem+block") & temp$event_type==c("problem_show"),],
                             .(user_id), summarise,
                             prb_showMods = length(unique(mod_hex_id)),
                             prb_showEvents = length(user_id),
                             prb_showTime = sum(period))[2:4])
    } else {
      prb <- cbind(prb,matrix(0,nrow=1,ncol=3))
      names(prb)[10:12] <- c("prb_showMods","prb_showEvents","prb_showTime")
    }
    prb$prb_time <- sum(prb[,c(8,12)])
    prb$prb_navEvents <- prb$prb_events - sum(prb[,6:7])
    prb <- prb[,c(1,4,10,2,3,11,14,5,6,8,9,13,12,7)]
  } else {
    prb$user_id <- temp$user_id[1]
    prb <- as.data.frame(cbind(t(prb), matrix(data=rep(0,13),nrow=1,ncol=13)))
    names(prb) <- c("user_id","prb_mod","prb_showMods","prb_meanDate","prb_events","prb_showEvents",
                    "prb_navEvents","prb_attempts","prb_meanAttempts","prb_correct","prb_totalPoints",
                    "prb_time","prb_showTime","prb_checkTime")
  }
  #Combined student problem stats to table of all students' problem stats
  prbData <- rbind(prbData,prb)

  #Open Assessment Events
  oa <- NULL
  if(nrow(temp[temp$module_type==c("openassessment+block"),])>1){
    oa <- ddply(temp[temp$module_type==c("openassessment+block"),], .(user_id), summarise,
                oa_mods = length(unique(mod_hex_id)),
                oa_events = length(user_id)
                ) 
    #Create Submissions
    if(nrow(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.create_submission"),])>1){
      oa<- cbind(oa,ddply(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.create_submission"),],
                          .(user_id), summarise,
                          oa_cSubMods = length(unique(mod_hex_id)),
                          oa_cSubEvents = length(user_id),
                          oa_cSubTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[4:6] <- c("oa_cSubMods","oa_cSubEvents","oa_cSubTime")
    }
    #Saved Submission
    if(nrow(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.save_submission"),])>1){
      oa<- cbind(oa,ddply(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.save_submission"),],
                          .(user_id), summarise,
                          oa_saveSubMods = length(unique(mod_hex_id)),
                          oa_saveSubEvents = length(user_id),
                          oa_saveSubTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[7:9] <- c("oa_saveSubMods","oa_saveSubEvents","oa_saveSubTime")
    }   
    #Access Peers Works
    if(nrow(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.peer_assess"),])>1){
      oa<- cbind(oa,ddply(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.peer_assess"),],
                          .(user_id), summarise,
                          oa_peerAccessMods = length(unique(mod_hex_id)),
                          oa_peerAccessEvents = length(user_id),
                          oa_peerAccessTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[10:12] <- c("oa_peerAccessMods","oa_peerAccessEvents","oa_peerAccessTime")
    }
    #Get Peer Assessments to Review
    if(nrow(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.get_peer_submission"),])>1){
      oa<- cbind(oa,ddply(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.get_peer_submission"),],
                          .(user_id), summarise,
                          oa_getPeerMods = length(unique(mod_hex_id)),
                          oa_getPeerEvents = length(user_id),
                          oa_getPeerTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[13:15] <- c("oa_getPeerMods","oa_getPeerEvents","oa_getPeerTime")
    }
    #Self Assessment
    if(nrow(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.self_assess"),])>1){
      oa<- cbind(oa,ddply(temp[temp$module_type==c("openassessment+block") & temp$event_type==c("openassessmentblock.self_assess"),],
                          .(user_id), summarise,
                          oa_selfAssessMods = length(unique(mod_hex_id)),
                          oa_selfAssessEvents = length(user_id),
                          oa_selfAssessTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[16:18] <- c("oa_selfAssessMods","oa_selfAssessEvents","oa_selfAssessTime")
    }
    #ReOrder Fields
    oa <- oa[,c(1,2,4,7,10,13,16,3,5,8,11,14,17,6,9,12,15,18)]
    } else {
    oa <- as.data.frame(matrix(data=rep(0,18),nrow=1,ncol=18))
    names(oa) <- c("user_id","oa_mods","oa_cSubMods","oa_saveSubMods","oa_peerAccessMods",
                    "oa_getPeerMods","oa_selfAssessMods","oa_events","oa_cSubEvents",
                    "oa_saveSubEvents","oa_peerAccessEvents","oa_getPeerEvents",
                    "oa_selfAssessEvents","oa_cSubTime","oa_saveSubTime",
                    "oa_peerAccessTime","oa_getPeerTime","oa_selfAssessTime")
    oa$user_id <- temp$user_id[1]
    }
  #Combined student problem stats to table of all students' problem stats
  oaData <- rbind(oaData,oa)
  
  #Navigation Events
  nav <- NULL
  #Sequence to next module
  if(nrow(temp[temp$event_type==c("seq_next"),])>1){
    nav <- ddply(temp[temp$event_type==c("seq_next"),], .(user_id), summarise,
                seqNextEvents = length(unique(mod_hex_id)),
                seqNextTime = sum(period),
                meanSeqNextTime = mean(period),
                meanSeqNextDis = mean(dis),
                sdSeqNextDis = sd(dis)
                )
  } else {
    nav <- as.data.frame(cbind(nav,matrix(rep(0,6),nrow=1,ncol=6)))
    names(nav) <- c("user_id","seqNextEvents","seqNextTime","meanSeqNextTime","meanSeqNextDis","sdSeqNextDis")
    nav$user_id <- temp$user_id[1]
  }
  #Sequence to previous module
  if(nrow(temp[temp$event_type==c("seq_prev"),])>1){
    nav <- cbind(nav,ddply(temp[temp$event_type==c("seq_prev"),], .(user_id), summarise,
                           seqPrevEvents = length(unique(mod_hex_id)),
                           seqPrevTime = sum(period),
                           meanSeqPrevTime = mean(period),
                           meanSeqPrevDis = mean(dis),
                           sdSeqPrevDis = sd(dis)
                           )[2:6])
  } else {
    nav <- cbind(nav,matrix(0,nrow=1,ncol=5))
    names(nav)[7:11] <- c("seqPrevEvents","seqPrevTime","meanSeqPrevTime","meanSeqPrevDis","sdSeqPrevDis")
  }
  #Sequence to GoTo module
  if(nrow(temp[temp$event_type==c("seq_goto"),])>1){
    nav <- cbind(nav,ddply(temp[temp$event_type==c("seq_goto"),], .(user_id), summarise,
                           seqGotoEvents = length(unique(mod_hex_id)),
                           seqGotoTime = sum(period),
                           meanSeqGotoTime = mean(period),
                           meanSeqGotoDis = mean(dis),
                           sdSeqGotoDis = sd(dis)
    )[2:6])
  } else {
    nav <- cbind(nav,matrix(0,nrow=1,ncol=5))
    names(nav)[12:16] <- c("seqGotoEvents","seqGotoTime","meanSeqGotoTime","meanSeqGotoDis","sdSeqGotoDis")
  }  
  #Accessed module
  if(nrow(temp[temp$event_type==c("mod_access"),])>1){
    nav <- cbind(nav,ddply(temp[temp$event_type==c("mod_access"),], .(user_id), summarise,
                           modAccessEvents = length(unique(mod_hex_id)),
                           modAccessTime = sum(period),
                           meanModAccessTime = mean(period),
                           meanModAccessDis = mean(dis),
                           sdModAccessDis = sd(dis)
    )[2:6])
  } else {
    nav <- cbind(nav,matrix(0,nrow=1,ncol=5))
    names(nav)[17:21] <- c("modAccessEvents","modAccessTime","meanModAccessTime","meanModAccessDis","sdModAccessDis")
  }
  #reorder columns
  nav <- nav[,c(1,2,7,12,17,3,8,13,18,4,9,14,19,5,6,10,11,15,16,20,21)]
  #Combined student problem stats to table of all students' problem stats
  navData <- rbind(navData,nav)

}
rm(temp,nav,oa,prb,vid,std)

#Overall open assessment time variable
oaData$oa_time <- rowSums(oaData[,14:18])

#Dataframe clean-up
vidData$user_id <- as.integer(unlist(vidData$user_id))
for(i in 1:ncol(vidData)-1){
  vidData[,i+1] <- as.numeric(unlist(vidData[,i+1]))
}
prbData$user_id <- as.integer(unlist(prbData$user_id))
for(i in 1:ncol(prbData)-1){
  prbData[,i+1] <- as.numeric(unlist(prbData[,i+1]))
  }

#Join of student list with general activity statistics
students <- join(students,stdData)

##Save separate output data files
#Video Data
write.csv(join(students,vidData),
           file=paste0(path_output,subDir[1],"/",courseID,"-",numLogs,"_std-videoActivity.csv"),
           row.names = FALSE)
#Problem Data
write.csv(join(students,prbData),
          file=paste0(path_output,subDir[1],"/",courseID,"-",numLogs,"_std-problemActivity.csv"),
          row.names = FALSE)
#Open Assessments Data
write.csv(join(students,oaData),
          file=paste0(path_output,subDir[1],"/",courseID,"-",numLogs,"_std-openAssessActivity.csv"),
          row.names = FALSE)
#Navigation Data
write.csv(join(students,navData),
          file=paste0(path_output,subDir[1],"/",courseID,"-",numLogs,"_std-navigationActivity.csv"),
          row.names = FALSE)

##Creates final analysis data frame for visualization work
#Adds video data fields to students data table
students <- join(students,vidData[,c(1:4,10)])
#Adds problem data fields to students data table
students <- join(students,prbData[,c(1,2,4,5,8,10:12)])
#Adds assessments data fields to students data table
students <- join(students,oaData[,c(1,2,8,11,12,16,17,19)])

#Adds problem data fields to students data table
students <- join(students,navData[,c(1:9)])
#ReOrder Columns
students <- students[,c(1:8,13,17,10,12,16,23,11,14,18,24:26,30:33,9,15,22,29,27,28,34:37,19:21)]
rm(stdData,navData,oaData,prbData,vidData)

#difference in mean video date and mean problem date in data
#a positive value indicates that, on average, a student watched videos prior to working on problem modules
#a negative value indicates that a student attempted problems before watching videos
#the closer the value to 0  weaker this signal is, while large values indicate a
students$meanDifvidPrbDates <- students$vid_meanDate - students$prb_meanDate

#Student General Activity
write.csv(students,
          file=paste0(path_output,subDir[1],"/",courseID,"-",numLogs,"_std-generalActivity.csv"),
          row.names = FALSE)
		  
######### Finishing Details ########## 
#Indicate completion
message("\n**** Complete! ****\n")

## _Script processing time feedback #####
#print the amount of time the script required
cat("\n\n\nComplete script processing time details (in sec):\n")
print(proc.time() - start)

## _Clear environment variables
rm(list=ls())
