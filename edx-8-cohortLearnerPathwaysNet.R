## ====================================================================================== ##
# Title:        Creating Cohort Learner Pathway Networks Using Student Event Logs
# Project:      edX user trajectory analysis
#
#     Copyright 2020-2021 Michael Ginda
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#     
#     http://www.apache.org/licenses/LICENSE-2.0
#     
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
# Authors:      Michael Ginda
# Affiliation:  Indiana University
# 
# Description:  This script takes processed students' edX event log (CSV) to 
#               create a learner transition networks using the igraph library. 
#               The network represents student's transition between EdX blocks 
#               learning modules using a student's event log of click actions in 
#               an EdX course. The script relies on two data sources:
#                  * course module sequencing and hierarchy structure extracted 
#                    from a course state database;
#                  * individual student's event logs formatted using the 
#                    script, edX-studentLogFormatter.R.
#
#               Networks represent events at the lowest level an EdX course's 
#               module hierarchy structure (level 4). Network objects are exported
#               as JSON graphs, and as a node and edge list CSV files, in the 
#               project directory, "./networks/".
# 
# File input stack: 
#            1) A processed edX Course structure and content module list:
#               - {org}+{course}+{term}-module-lookup.csv;
#               - extracted by script, edX-0-courseStructureMeta.R;
#            2) A list of student userIDs from an edX course that are active
#	           		and have usable data:
#               - {org}-{course}-{term}-auth_user-students-active.csv;
#               - extracted by script, edX-3-studentLogFormatter.R;
#            3) A "studentevents_processed" directory with one or more
#               CSV of processed student event log file(s):
#               - {userID}.csv;
#               - generated by script, edX-3-studentLogFormatter.R, 
#                   
# Output files:                        
#            1) A project directory "./networks/" containing one or 
#               more JSON learner trajectory networks:
#               - {org}-{course}-{term}-{userID}.json;
#            2) A project directory "./networks/nodes/" containing one or 
#               more CSV student node lists:
#               - {userID}-nodes.csv;
#            3) A project directory "./networks/edges/" containing one or 
#               more sets of CSV student edge lists:
#               - {userID}-edges.csv;
#            4) A list capturing student userIDs that are associated with
#               a learner trajectory network after processing:
#               - {org}-{course}-{term}-auth_user-students-hasNet.csv;
#            5) A list capturing student userIDs that are associated with only
#               one event after processing:
#               - {org}-{course}-{term}-auth_user-students-auth_user-oneEvent.csv;
#            6) A list capturing student userIDs that have no network if self-loops
#               are removed during processing to create a learner trajectory network;
#				        (not always produced):
#               - {org}-{course}-{term}-auth_user-students-auth_user-selfLoops.csv;
#
# Package dependencies: dplyr, plyr, magrittr, igraph, tcltk
#
# Change log:
#   2020.06.22  
# 
## ====================================================================================== ##
#### Environment Setup ####
rm(list=ls())

#### Set up environment ####
# Load packages
library(tcltk)
library(plyr)
library(dplyr)
library(magrittr)
library(igraph)

#### Paths to data ####
#Checks if a user has previously assign a path with a prior script 
#If false, lets user assign path to previous processing output files of an
#edX course using the a previous processing scripts from this pipeline.
if(exists("path_data")==FALSE){
  path_data = tclvalue(tkchooseDirectory())
}

if(exists("path_output")==FALSE){
  path_output = tclvalue(tkchooseDirectory())
}

#### Load relevant data ####
#The pattern parameter identifies the outputs of the edX-1-studentUserList.R script
users <- read.csv(list.files(full.names = T, recursive = FALSE, 
                             path = paste0(path_output,"/analysis/studentActivity/"),
                             pattern = "-selectedActivity.csv$"), header=T)[c(1,6,7,10,11,13,15:17)]

#Read in course structure - processed
courseStr <- read.csv(list.files(full.names = TRUE, recursive = FALSE, 
                                 path = paste0(path_output,"/course/"),
                                 pattern = "module-lookup.csv"),header=T)
courseID <- gsub("\\+","\\-",courseStr$courseID)[1]

#Read in a list of student edges, append data to master edge list
fileEdges <- list.files(full.names = TRUE, recursive = FALSE, 
                        path = paste0(path_output,"/networks/edges/"),
                        pattern = ".csv$")

kmed <- read.csv(list.files(full.names = TRUE, recursive = FALSE, 
                            path = paste0(path_output,"/analysis/"),
                            pattern = "clusters.csv$"),header=T)

#### Create list of students' aggregated course pathway network ####
# Temp data frames for aggregating data
tmp <- NA
tmp2 <- NA

# List for set student network edge lists
stdNetList <- NA
# Sets session condition for loop calculations
# Sess= F, no sessions are considered in the student networks
# Sess= T, session data is preserved in the student networks
sess <- F

# Loop for aggregating individual student's course pathways logs
# and adding to the student list.
for(i in 1:length(fileEdges)){
  message("Processing edge list ", i, " of ", length(fileEdges))
  #Read in edge list
  tmp <- read.csv(fileEdges[i])[c(1,2,8:13)]
  #Fix dir labels for self loops
  if(length(tmp[tmp$sl==1,]$sl)){
    tmp[tmp$sl==1,]$dir <- 's'
  }
  #Refactoring session identifiers
  tmp$t.tsession <- factor(tmp$t.tsession)
  levels(tmp$t.tsession) <- seq_along(levels(tmp$t.tsession))
  tmp$t.tsession <- as.numeric(tmp$t.tsession)
  #Update from and to fields with temporal session identifier
  tmp$from_s <- paste0(tmp$from,"-",tmp$t.tsession)
  tmp$to_s <- paste0(tmp$to,"-",tmp$t.tsession)
  #Value added for summing up edge count
  tmp$val <- 1
  #Add sequence value to data
  tmp$seq <- rownames(tmp)
  #Aggregate function
  #Check to aggregate by student session or not
  if(sess==T){
    tmp2 <- unique(tmp[,c("from_s","from","to_s","to")])
    tmp <- ddply(tmp, .(from_s,to_s,user_id), summarize,
                 weight = sum(val),
                 dis = mean(dis),
                 sl = mean(sl),
                 session = mean(t.tsession),
                 seq_min =  as.numeric(min(seq))) %>% 
           arrange(seq_min)
    #Identifies original module id (used distance calc revisisons)
    tmp <- join(tmp,tmp2[,1:2], by="from_s")
    tmp <- join(tmp,tmp2[,3:4], by="to_s")
    names(tmp)[c(1,2,9,10)] <- c("from","so","from_o","to_o")
  } else {
    tmp <- ddply(tmp, .(from,to,user_id), summarize,
                 weight = sum(val),
                 dis = mean(dis),
                 sl = mean(sl),
                 seq_min = as.numeric(min(seq))) %>% 
           arrange(seq_min)
  }
  #Appends network to list of all student pathway networks
  if(is.data.frame(stdNetList)==F){
    stdNetList <- tmp
  } else {
    stdNetList <- bind_rows(stdNetList,tmp)  
  }
}
rm(tmp,tmp2)

#### Revising distance measure for nodes ####
#Module order is based on full tree order with course structure data
#Log data does not preserve structural actions, and so distances values are larger than
#nodes in network representation
#Subset content modules from course structure (Levels 0-3 are organizational modules)
courseStr <- courseStr[courseStr$treelevel==4,][c(2:3,4,7,10:12)]
#Sets new order (linear), but preserves tree sort order values
courseStr$orderNew <- 1:nrow(courseStr)
#Check to see of process preserves sessions or not
if(sess==T){
  #Needs testing
  #Rename course structure fields to join
  names(courseStr)[c(1,8)] <- c("from_o","ordF")
  #Update from nodes order values for 'from' nodes
  stdNetList <- join(stdNetList,courseStr[,c(1,8)], by="from_o")
  #Rename course structure fields for join
  names(courseStr)[c(1,8)] <- c("to_o","ordT")
  #Update to nodes order values for 'to' nodes
  stdNetList <- join(stdNetList,courseStr[,c(1,8)], by="to_o")
  #Rename course structure fields for join 
  names(courseStr)[c(1,8)] <- c("id","orderNew")
} else {
  #Rename course structure fields for join 
  names(courseStr)[c(1,8)] <- c("from","ordF")
  #Update from and to node order values for 'from' nodes
  stdNetList <- join(stdNetList,courseStr[,c(1,8)], by="from")
  #Rename course structure fields for join 
  names(courseStr)[c(1,8)] <- c("to","ordT")
  #Update from and to node order values for 'to' nodes
  stdNetList <- join(stdNetList,courseStr[,c(1,8)], by="to")
  #Rename course structure fields for clarity
  names(courseStr)[c(1,8)] <- c("id","orderNew")
}
#Calculate revised distance measure with new order values
stdNetList$disRevised <- stdNetList$ordT - stdNetList$ordF

#### Export list of aggregated student pathway networks
#Saving list of students' aggregated edge lists
if(sess==T){
  write.csv(stdNetList, paste0(path_output,"/networks/",courseStr$courseID[1],"-stdAgg-edgeList-sessionLevel.csv"),
            row.names = F)
} else {
  write.csv(stdNetList, paste0(path_output,"/networks/",courseStr$courseID[1],"-stdAgg-edgeList.csv"),
            row.names = F)
}

#### Overall student pathway network edge and node lists (aggregated for whole course) ####
#Aggegate to an overall network for all students
if(sess==T){
  # Add to this section
  
  
  
  
  # write.csv(stdNetList, paste0(path_output,"/networks/",courseStr$courseID[1],"-stdAgg-edges-sessionLevel.csv"),
  #           row.names = F)
  
  
  
  
  
  # write.csv(nodes, paste0(path_output,"/networks/",courseStr$courseID[1],"-stdAgg-nodes-sessionLevel.csv"),
  #           row.names = F)
} else {
  #Calculate edge list stats
  edges <- ddply(stdNetList,.(from,to),summarize,
                 stds = length(unique(user_id)),
                 weight = sum(weight),
                 dis = mean(disRevised),
                 sl = mean(sl))
  #Save edge list
  write.csv(edges, paste0(path_output,"/networks/",courseStr$courseID[1],"-stdAgg-edges.csv"),
            row.names = F)
  #Calculate node stats
  nodes <- ddply(stdNetList,.(from),summarize,
                 stds = length(unique(user_id)),
                 count = sum(weight))
  #Append nodes with course structure data
  names(courseStr)[1] <- names(nodes)[1] <- "name"
  names(courseStr)[c(4,8)] <- c("order_o","order")
  nodes <- join(courseStr[,c(1:3,8,5:7)],nodes,"name")
  #Replace NA values with 0
  nodes[is.na(nodes[,c(9)]),c(9)] <- 0
  nodes[is.na(nodes[,c(8)]),c(8)] <- 0
  #Save node list
  write.csv(nodes, paste0(path_output,"/networks/",courseStr$courseID[1],"-stdAgg-nodes.csv"),
            row.names = F)
}

#Agg Studen Pathway Net Density
nrow(edges)/length(nodes$name)^2
nrow(edges)/length(unique(edges$to))^2

#Create a graph of the network
g <- graph_from_data_frame(d=edges, vertices=nodes, directed=T)
