## ====================================================================================== ##
# Title:        Student Interaction Feature Extraction Using edX Student Event Logs       
# Project:      edX user trajectory analysis
#
#     Copyright 2018-2019 Michael Ginda
#     Licensed under the Apache License, Version 2.0 (the "License");
#     you may not use this file except in compliance with the License.
#     You may obtain a copy of the License at
#     
#     http://www.apache.org/licenses/LICENSE-2.0
#     
#     Unless required by applicable law or agreed to in writing, software
#     distributed under the License is distributed on an "AS IS" BASIS,
#     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#     See the License for the specific language governing permissions and
#     limitations under the License.
#
# Authors:      Michael Ginda
# Affiliation:  Indiana University
# 
# Description:  This script processes sets of processed student edX logs to extract 
#               frequential statistics of student activity in an EdX course (e.g. number 
#               of sessions, events, unique modules, event_types), and basic temporal 
#               period. The script will calculate statistics courses that use video 
#               modules, ungraded problem modules, and open assessment modules, and 
#               navigation events. Other types of course module types and associated  
#               types of events that may be apart of an EdX course are not included
#               here, but may be added at a later date.
#                
# File input stack: 
#               1) Course metadata file that describe course identifiers,
#                            - generated by script "edX-1-courseStructureMeta.R";
#               2) A list of student identifiers for students with usable logs 
#                  in the data set;
#               3) Course User Data table to extract final student grades 
#                  and self-reported demographics;
#               4) Folders containing one or more "*.csv" processed student event logs,
#                            - generated by script "edX-4-eventLogFormatter.R"
#               5) A course structure data set appended with aggregated module use
#                  statistics for group of student, based on their learner trajectory
#                  networks,
#                            - generated by script "edX-6-StudentEventAgg.R"
#
# Output files:
#               1) A data table of student demographics and overall performance 
#                  and activity features:
#                   - {org}-{course Identifier}-{N#}_std-overallActivity.csv;
#               2) A data table of student demographic, overall performance 
#                  and activity features and navigation features:
#                   - {org}-{course Identifier}-{N#}_std-navigationActivity.csv
#               3) A data table of student demographic, overall performance 
#                  and activity features and problem features:
#                   - {org}-{course Identifier}-{N#}_std-problemActivity.csv
#               4) A data table of student demographic, overall performance 
#                  and activity features and video features:
#                   - {org}-{course Identifier}-{N#}_std-videoActivity.csv
#               5) A data table of student demographic, overall performance 
#                  and activity features and apen assessment features:
#                   - {org}-{course Identifier}-{N#}_std-openAssessActivity.csv
#               6) A data table of student demographic, overall performance 
#                  and activity features and select features:
#                   - {org}-{course Identifier}-{N#}_std-selectedActivity.csv
#
# Package dependencies: tcltk, plyr
#
# Changelog:
#   2019.05.22. Updated code to correct field list export for the output file 
#               {org}-{course Identifier}-{N#}_std-overallActivity.csv; updated
#               Script description of outputfiles.
#
## ====================================================================================== ##
#### Environment Setup ####
rm(list=ls()) 
options(scipen=90)

## Load required packages 
require("plyr")       #Joins
require("tcltk2")     #for OS independant GUI file and folder selection

#### Paths ####
#Assign path for project processing and analysis results (Directory of a course level analysis)
path_output = tclvalue(tkchooseDirectory())

#### Creates SudDirectory for Visualizations ####
subDir = c("studentActivity")
for(i in 1:length(subDir)){
  if(!file_test("-d", file.path(paste0(path_output,"/analysis/"), subDir[i]))){
    if(file_test("-f", file.path(paste0(path_output,"/analysis/"), subDir[i]))){
      stop("Path can't be created because a file with that name already exists.")
    } else {
      dir.create(file.path(path_output, subDir[i]))
    }
  }
}

# start timer to track how long the script takes to execute
start <-  proc.time() #save the time (to compute elapsed time of script)

#### Load course metadata ####
#CSV of course modules data extracted from the Course Structure, found in the
#edX student user database file: {org}-{course}-{run}-module-lookup.csv
courseMeta <- read.csv(file=list.files(full.names = TRUE, recursive = FALSE, 
                                       path = paste0(path_output,"/course/"),
                                       pattern = "meta.csv$"), header=T)
#Extracts course identifier
courseID <- as.character(courseMeta$id)
rm(courseMeta)

#### Read in list of students with learner trajectory networks ####
#Students have network files that can be processed
students <- read.csv(list.files(full.names = TRUE, recursive = FALSE, 
                                path = paste0(path_output,"/userlists/"),
                                pattern = "hasNet.csv$"))
names(students)[1] <- "id"

## Indicates if statistics calculated in script are added to final data set.
# Note that the script automatically calculates and saves these records out, but not to final data.
oaEvents=T
prbEvents=T
vidEvents=T
navEvents=F

#### Loads in edX active student user list ####
#Reads in user id, grade, certificate status, gender, year of birth (yob), and level of education (loe)
users <- read.csv(file=list.files(full.names = TRUE, recursive = FALSE, 
                                       path = paste0(path_output,"/userlists/"),
                                       pattern = "students.csv$"), header=T)

#Joins of student list to grade and certificate
students <- subset(users, id %in% students$id)
rm(users)
names(students)[1] <- "user_id"

#### Creates list paths to laod individual student event logs ####
logFiles <- paste0(path_output,"/studentevents_processed/",students$user_id,".csv")
numLogs <- length(logFiles) 

#### Creates dataframe shells for user analysis results ####
stdData <- NULL
vidData <- NULL
prbData <- NULL
oaData <- NULL
navData <- NULL

#### Loop for calculating all user statistics ####
for(i in 1:numLogs){
  message("Processing log file ", i, " of ", numLogs)
  print(proc.time() - start)
  ## Load data set
  temp <- read.csv(logFiles[i])
  temp$time <- as.POSIXct(temp$time, tz="EST",format='%Y-%m-%d %H:%M:%S')
  
  #Navigation Distance between events
  temp$dis <- NA
  temp[1:nrow(temp)-1,]$dis <- temp[2:nrow(temp),]$order - temp[1:nrow(temp)-1,]$order
  temp[nrow(temp),]$dis <- 0
  
  #count statistics for general activity
  std <- ddply(temp, .(user_id), summarise,
               sessions = length(unique(tsess)),
               days_unq = length(unique(trunc(time,"days"))),
               total_time = sum(period),
               mods_unq =  length(unique(mod_hex_id)),
               events = length(user_id)
              ) 
  stdData <- rbind(stdData,std)
  
  #### Video Event statistics ####
  vid <- NULL
  if(nrow(temp[grepl("video",temp$module_type)==T,])>1){
    vid <- ddply(temp[grepl("video",temp$module_type)==T,], .(user_id), summarise,
                 vid_mods = length(unique(mod_hex_id)),
                 vid_events = length(user_id)
                 )  
    #Play Video Stats
    if(nrow(temp[grepl("video",temp$module_type)==T & temp$event_type==c("play_video"),])>=1){
      vid <- cbind(vid,ddply(temp[grepl("video",temp$module_type)==T & temp$event_type==c("play_video"),],
                             .(user_id), summarise,
                             vid_playEvents = length(user_id),
                             vid_playTime = sum(period))[2:3])
    } else {
      vid_playEvents <- 0
      vid_playTime <- 0
      vid <-cbind(vid,cbind(vid_playEvents,vid_playTime))      
      rm(vid_playEvents,vid_playTime)
    }
    #Pause Video Stats
    if(nrow(temp[grepl("video",temp$module_type)==T  & temp$event_type==c("pause_video"),])>=1){
      vid <- cbind(vid,ddply(temp[grepl("video",temp$module_type)==T  & temp$event_type==c("pause_video"),],
                             .(user_id), summarise,
                             vid_pauseEvents = length(user_id),
                             vid_pauseTime = sum(period))[2:3])
    } else {
      vid_pauseEvents <- 0
      vid_pauseTime <- 0
      vid <-cbind(vid,cbind(vid_pauseEvents,vid_pauseTime))      
      rm(vid_pauseEvents,vid_pauseTime)
    }
    #Seek Video Stats
    if(nrow(temp[grepl("video",temp$module_type)==T  & temp$event_type==c("seek_video"),])>=1){
      vid <- cbind(vid,ddply(temp[grepl("video",temp$module_type)==T  & temp$event_type==c("seek_video"),],
                             .(user_id), summarise,
                             vid_seekEvents = length(user_id),
                             vid_seekTime = sum(period))[2:3])
    } else {
      vid_seekEvents <- 0
      vid_seekTime <- 0
      vid <-cbind(vid,cbind(vid_seekEvents,vid_seekTime))      
      rm(vid_seekEvents,vid_seekTime)
    }
    #Stop Video Stats
    if(nrow(temp[grepl("video",temp$module_type)==T  & temp$event_type==c("stop_video"),])>1){
      vid <- cbind(vid,ddply(temp[grepl("video",temp$module_type)==T  & temp$event_type==c("stop_video"),],
                             .(user_id), summarise,
                             vid_stopEvents = length(user_id),
                             vid_stopTime = sum(period))[2:3])
    } else {
      vid_stopEvents <- 0
      vid_stopTime <- 0
      vid <-cbind(vid,cbind(vid_stopEvents,vid_stopTime))      
      rm(vid_stopEvents,vid_stopTime)
    }
    #Video Navigation Event Count (seq and mod_access events)
    vid$vid_navEvents <- vid$vid_events - sum(vid[,c(4,6,8,10)])
    #Video interaction time (play, pause, seek; stop excluded)
    vid$vid_time <- sum(vid[,c(5,7,9,11)])
    vid <- vid[,c(1:4,6,8,10,12,13,5,7,9,11)]
    } else {
    vid$user_id <- temp$user_id[1]
    vid <- as.data.frame(cbind(t(vid), matrix(data=rep(0,12),nrow=1,ncol=12)))
    names(vid) <- c("user_id","vid_mods","vid_events","vid_playEvents","vid_pauseEvents","vid_seekEvents", 
                    "vid_stopEvents","vid_navEvents","vid_time","vid_playTime","vid_pauseTime","vid_seekTime","vid_stopTime")
    }
  #Combined student video stats to table of all students video stats
  vidData <- rbind(vidData,vid)

  ##### Problems Event Statistics ####
  prb <- NULL
  if(nrow(temp[grepl("problem",temp$module_type)==T,])>1){
    prb <- ddply(temp[grepl("problem",temp$module_type)==T,], .(user_id), summarise,
                 prb_events = length(user_id)
                 ) 
    #Problem Check
    if(nrow(temp[grepl("problem",temp$module_type)==T & temp$event_type==c("problem_check"),])>1){
      prb <- cbind(prb,ddply(temp[grepl("problem",temp$module_type)==T & temp$event_type==c("problem_check"),],
                             .(user_id), summarise,
                             prb_mod = length(unique(mod_hex_id)),
                             prb_attempts = length(user_id),
                             prb_meanAttempts = length(user_id)/length(unique(mod_hex_id)),
                             prb_checkTime = sum(period),
                             prb_correct = length(success[temp$success==c("correct") & !is.na(temp$success)]),
                             prb_totalPoints = sum(grade))[,2:7]) 
    } else {
      prb <- cbind(prb,matrix(0,nrow=1,ncol=6))
      names(prb)[3:8] <- c("prb_mod","prb_correct","prb_attempts","prb_meanAttempts","prb_checkTime","prb_totalPoints")
    }
    #Problem Show
    if(nrow(temp[grepl("problem",temp$module_type)==T & temp$event_type==c("problem_show"),])>1){
      prb <- cbind(prb,ddply(temp[grepl("problem",temp$module_type)==T & temp$event_type==c("problem_show"),],
                             .(user_id), summarise,
                             prb_showMods = length(unique(mod_hex_id)),
                             prb_showEvents = length(user_id),
                             prb_showTime = sum(period))[2:4])
    } else {
      prb <- cbind(prb,matrix(0,nrow=1,ncol=3))
      names(prb)[9:11] <- c("prb_showMods","prb_showEvents","prb_showTime")
    }
    prb$prb_time <- sum(prb[,c(6,11)])
    prb$prb_navEvents <- prb$prb_events - sum(prb$prb_attempts,prb$prb_showEvents)
    prb <- prb[,c(1,3,9,2,10,13,4,5,7,8,12,11,6)]
  } else {
    prb$user_id <- temp$user_id[1]
    prb <- as.data.frame(cbind(t(prb), matrix(data=rep(0,12),nrow=1,ncol=12)))
    names(prb) <- c("user_id","prb_mod","prb_showMods","prb_events","prb_showEvents",
                    "prb_navEvents","prb_attempts","prb_meanAttempts","prb_correct","prb_totalPoints",
                    "prb_time","prb_showTime","prb_checkTime")
  }
  #Combined student problem stats to table of all students' problem stats
  prbData <- rbind(prbData,prb)

  #### Open Assessment Events Statistics ####
  oa <- NULL
  if(nrow(temp[grepl("openassessment",temp$module_type)==T,])>1){
    oa <- ddply(temp[grepl("openassessment",temp$module_type)==T,], .(user_id), summarise,
                oa_mods = length(unique(mod_hex_id)),
                oa_events = length(user_id)
                ) 
    #Create Submissions
    if(nrow(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.create_submission"),])>1){
      oa<- cbind(oa,ddply(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.create_submission"),],
                          .(user_id), summarise,
                          oa_cSubMods = length(unique(mod_hex_id)),
                          oa_cSubEvents = length(user_id),
                          oa_cSubTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[4:6] <- c("oa_cSubMods","oa_cSubEvents","oa_cSubTime")
    }
    #Saved Submission
    if(nrow(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.save_submission"),])>1){
      oa<- cbind(oa,ddply(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.save_submission"),],
                          .(user_id), summarise,
                          oa_saveSubMods = length(unique(mod_hex_id)),
                          oa_saveSubEvents = length(user_id),
                          oa_saveSubTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[7:9] <- c("oa_saveSubMods","oa_saveSubEvents","oa_saveSubTime")
    }   
    #Access Peers Works
    if(nrow(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.peer_assess"),])>1){
      oa<- cbind(oa,ddply(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.peer_assess"),],
                          .(user_id), summarise,
                          oa_peerAccessMods = length(unique(mod_hex_id)),
                          oa_peerAccessEvents = length(user_id),
                          oa_peerAccessTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[10:12] <- c("oa_peerAccessMods","oa_peerAccessEvents","oa_peerAccessTime")
    }
    #Get Peer Assessments to Review
    if(nrow(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.get_peer_submission"),])>1){
      oa<- cbind(oa,ddply(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.get_peer_submission"),],
                          .(user_id), summarise,
                          oa_getPeerMods = length(unique(mod_hex_id)),
                          oa_getPeerEvents = length(user_id),
                          oa_getPeerTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[13:15] <- c("oa_getPeerMods","oa_getPeerEvents","oa_getPeerTime")
    }
    #Self Assessment
    if(nrow(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.self_assess"),])>1){
      oa<- cbind(oa,ddply(temp[grepl("openassessment",temp$module_type)==T & temp$event_type==c("openassessmentblock.self_assess"),],
                          .(user_id), summarise,
                          oa_selfAssessMods = length(unique(mod_hex_id)),
                          oa_selfAssessEvents = length(user_id),
                          oa_selfAssessTime = sum(period))[2:4])
    } else {
      oa <- cbind(oa,matrix(0,nrow=1,ncol=3))
      names(oa)[16:18] <- c("oa_selfAssessMods","oa_selfAssessEvents","oa_selfAssessTime")
    }
    #ReOrder Fields
    oa <- oa[,c(1,2,4,7,10,13,16,3,5,8,11,14,17,6,9,12,15,18)]
    } else {
    oa <- as.data.frame(matrix(data=rep(0,18),nrow=1,ncol=18))
    names(oa) <- c("user_id","oa_mods","oa_cSubMods","oa_saveSubMods","oa_peerAccessMods",
                    "oa_getPeerMods","oa_selfAssessMods","oa_events","oa_cSubEvents",
                    "oa_saveSubEvents","oa_peerAccessEvents","oa_getPeerEvents",
                    "oa_selfAssessEvents","oa_cSubTime","oa_saveSubTime",
                    "oa_peerAccessTime","oa_getPeerTime","oa_selfAssessTime")
    oa$user_id <- temp$user_id[1]
    }
  #Combined student problem stats to table of all students' problem stats
  oaData <- rbind(oaData,oa)
  
  #### Navigation Events Statistics ####
  nav <- NULL
  #Sequence to next module
  if(nrow(temp[temp$event_type==c("seq_next"),])>1){
    nav <- ddply(temp[temp$event_type==c("seq_next"),], .(user_id), summarise,
                seqNextEvents = length(unique(mod_hex_id)),
                seqNextTime = sum(period),
                meanSeqNextTime = mean(period),
                meanSeqNextDis = mean(dis),
                sdSeqNextDis = sd(dis)
                )
  } else {
    nav <- as.data.frame(cbind(nav,matrix(rep(0,6),nrow=1,ncol=6)))
    names(nav) <- c("user_id","seqNextEvents","seqNextTime","meanSeqNextTime","meanSeqNextDis","sdSeqNextDis")
    nav$user_id <- temp$user_id[1]
  }
  #Sequence to previous module
  if(nrow(temp[temp$event_type==c("seq_prev"),])>1){
    nav <- cbind(nav,ddply(temp[temp$event_type==c("seq_prev"),], .(user_id), summarise,
                           seqPrevEvents = length(unique(mod_hex_id)),
                           seqPrevTime = sum(period),
                           meanSeqPrevTime = mean(period),
                           meanSeqPrevDis = mean(dis),
                           sdSeqPrevDis = sd(dis)
                           )[2:6])
  } else {
    nav <- cbind(nav,matrix(0,nrow=1,ncol=5))
    names(nav)[7:11] <- c("seqPrevEvents","seqPrevTime","meanSeqPrevTime","meanSeqPrevDis","sdSeqPrevDis")
  }
  #Sequence to GoTo module
  if(nrow(temp[temp$event_type==c("seq_goto"),])>1){
    nav <- cbind(nav,ddply(temp[temp$event_type==c("seq_goto"),], .(user_id), summarise,
                           seqGotoEvents = length(unique(mod_hex_id)),
                           seqGotoTime = sum(period),
                           meanSeqGotoTime = mean(period),
                           meanSeqGotoDis = mean(dis),
                           sdSeqGotoDis = sd(dis))[2:6])
  } else {
    nav <- cbind(nav,matrix(0,nrow=1,ncol=5))
    names(nav)[12:16] <- c("seqGotoEvents","seqGotoTime","meanSeqGotoTime","meanSeqGotoDis","sdSeqGotoDis")
  }  
  #Accessed module
  if(nrow(temp[temp$event_type==c("mod_access"),])>1){
    nav <- cbind(nav,ddply(temp[temp$event_type==c("mod_access"),], .(user_id), summarise,
                           modAccessEvents = length(unique(mod_hex_id)),
                           modAccessTime = sum(period),
                           meanModAccessTime = mean(period),
                           meanModAccessDis = mean(dis),
                           sdModAccessDis = sd(dis))[2:6])
  } else {
    nav <- cbind(nav,matrix(0,nrow=1,ncol=5))
    names(nav)[17:21] <- c("modAccessEvents","modAccessTime","meanModAccessTime","meanModAccessDis","sdModAccessDis")
  }
  #reorder columns
  nav <- nav[,c(1,2,7,12,17,3,8,13,18,4,9,14,19,5,6,10,11,15,16,20,21)]
  #Combined student problem stats to table of all students' problem stats
  navData <- rbind(navData,nav)

}
rm(nav,oa,prb,std,temp,vid)

#### Clean-Up of Results ####
#Overall open assessment time variable
oaData$oa_time <- rowSums(oaData[,14:18])

#Dataframe clean-up
vidData$user_id <- as.integer(unlist(vidData$user_id))
for(i in 1:ncol(vidData)-1){
  vidData[,i+1] <- as.numeric(unlist(vidData[,i+1]))
}
prbData$user_id <- as.integer(unlist(prbData$user_id))
for(i in 1:ncol(prbData)-1){
  prbData[,i+1] <- as.numeric(unlist(prbData[,i+1]))
}

#### Load module statistics based on student event log activity ####
## Set problem module stats for the course 
mods <- read.csv(file=list.files(full.names = TRUE, recursive = FALSE, 
                                 path = paste0(path_output,"/analysis/modules/"),
                                 pattern = "ModuleUseStats.csv$"), header=T)
#Total problem points in a course
maxPoints <- sum(mods[grepl("problem",mods$module.type)==T,]$maxPointsPrb,na.rm = T)
rm(mods)
#Total problem modules in a course
maxProbMods <- max(prbData$prb_mod)

#### Update Problem module use stats based on course module facts ####
#Percent of problem attempted 
prbData$perPrbModAttempted <- 0
prbData$perPrbModAttempted <- scale(ifelse(is.nan(prbData$prb_mod/maxProbMods),0,prbData$prb_mod/maxProbMods),center=F)
#Percentage of Total Problem Points Attempted
prbData$perCorrectAttempted <- 0
prbData$perCorrectAttempted <- scale(ifelse(is.nan(prbData$prb_correct/prbData$prb_mod),0,prbData$prb_correct/prbData$prb_mod),center=F)
#Percentage of Total Problem Points Possible
prbData$perTotalPtsOverall <- 0
prbData$perTotalPtsOverall <- scale(ifelse(is.nan(prbData$prb_totalPoints/maxPoints),0,prbData$prb_totalPoints/maxPoints),center=F)

#### Events per module accessed ####
stdData$eventsPerMod <- scale(stdData$events/stdData$mods_unq)
#Video Events per Video module accessed
vidData$vidEventsPerVidMod <- scale(ifelse(is.nan(vidData$vid_events/vidData$vid_mods),0,vidData$vid_events/vidData$vid_mods))
#Open Assessment Events per Open Assessment module accessed
oaData$oaEventsPerOaMod <- scale(ifelse(is.nan(oaData$oa_events/oaData$oa_mods),0,oaData$oa_events/oaData$oa_mods))

#### Temporal Event Calculations
#Time per events
stdData$timePerEvent <- scale((stdData$total_time/stdData$events)*60)
#Time per session
stdData$timePerSession <- scale(stdData$total_time/stdData$sessions)
#Time per video events
vidData$timePerVidEvent <- scale(ifelse(is.nan((vidData$vid_time/vidData$vid_events)*60),0,(vidData$vid_time/vidData$vid_events)*60))
#Time per problem events
prbData$timePerPrbEvent <- scale(ifelse(is.nan((prbData$prb_time/prbData$prb_events)*60),0,(prbData$prb_time/prbData$prb_events)*60))
#Time per open assessment events
oaData$timePerOaEvent <- scale(ifelse(is.nan((oaData$oa_time/oaData$oa_events)*60),0,(oaData$oa_time/oaData$oa_events)*60))

## Creates final analysis data frame for visualization work
#Join of student demographics and performance data with overall activity statistics
students <- join(students,stdData, by="user_id")

#### Reorganize data tables ####
vidData <- vidData[,c(1:3,14:15,4:13)]
prbData <- prbData[,c(1:3,14,4:9,15,10,16,11:13)]
oaData <- oaData[,c(1:8,20,9:13,19,21,14:18)]

#### Saving output results ####
#Overall activity
write.csv(students,
          file=paste0(path_output,"/analysis/",subDir[1],"/",courseID,"-",numLogs,"_std-overallActivity.csv"),
          row.names=FALSE, na="")
#Video Data
write.csv(join(students,vidData, by="user_id"),
          file=paste0(path_output,"/analysis/",subDir[1],"/",courseID,"-",numLogs,"_std-videoActivity.csv"),
          row.names=FALSE, na="")
#Problem Data
write.csv(join(students,prbData, by="user_id"),
          file=paste0(path_output,"/analysis/",subDir[1],"/",courseID,"-",numLogs,"_std-problemActivity.csv"),
          row.names=FALSE, na="")
#Open Assessments Data
write.csv(join(students,oaData, by="user_id"),
          file=paste0(path_output,"/analysis/",subDir[1],"/",courseID,"-",numLogs,"_std-openAssessActivity.csv"),
          row.names=FALSE, na="")
#Navigation Data
write.csv(join(students,navData, by="user_id"),
          file=paste0(path_output,"/analysis/",subDir[1],"/",courseID,"-",numLogs,"_std-navigationActivity.csv"),
          row.names=FALSE, na="")

#### Combines final data with selected feature set ####
#Adds video data fields to students data table
if(vidEvents==T){
  students <- join(students,vidData[,c(1:5,11)], by="user_id")
}
#Adds problem data fields to students data table
if(prbEvents==T){
  students <- join(students,prbData[,c(1,2,4,5,8,14,10:13)], by="user_id")  
}
#Adds assessments data fields to students data table
if(oaEvents==T){
  students <- join(students,oaData[,c(1,2,8,15,9,16)], by="user_id")  
}
#Adds problem data fields to students data table
if(navEvents==T){
  students <- join(students,navData[,c(1:9)], by="user_id") 
}
str(students)

#Clean up environment
rm(navData,oaData,vidData,prbData,stdData)
rm(navEvents,oaEvents,prbEvents,vidEvents)

## Student General Activity
write.csv(students,
          file=paste0(path_output,"/analysis/",subDir[1],"/",courseID,"-",numLogs,"_std-selectedActivity.csv"),
          row.names = FALSE,na="")

####  Finishing Details #### 
#Indicate completion
message("\n**** Complete! ****\n")

## Script processing time feedback
#print the amount of time the script required
cat("\n\n\nComplete script processing time details (in minutes):\n")
print((proc.time()[3] - start[3])/60)

## Clear environment variables
rm(list=ls())
